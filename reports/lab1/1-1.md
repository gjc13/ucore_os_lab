#1-1 ucore的编译过程
# 内核代码的编译

##编译中间文件
```
+ cc kern/init/init.c
i386-elf-gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o
+ cc kern/libs/readline.c
+ cc kern/libs/stdio.c
+ cc kern/debug/kdebug.c
+ cc kern/debug/kmonitor.c
+ cc kern/debug/panic.c
+ cc kern/driver/clock.c
+ cc kern/driver/console.c
+ cc kern/driver/intr.c
+ cc kern/driver/picirq.c
+ cc kern/trap/trap.c
+ cc kern/trap/trapentry.S
+ cc kern/trap/vectors.S
+ cc kern/mm/pmm.c
+ cc libs/printfmt.c
+ cc libs/string.c
```
以上是内核的代码的编译过程，将kern lib文件夹下的各个模块的源文件编译到obj文件夹下的中间文件中。

### 内核代码的链接
由于内核代码的执行是直接跑在裸机中的，内存布局自然和跑在操作系统上的elf文件不同。所以需要使用ld script手工指定内存布局并且导出一些和内存布局紧密相关的符号。ldscript中使用.表明当前内存段的目标地址。通过声明内存段依次将段在elf中排布内存地址。

kernel.ld中主要和内核执行有关的部分如下:
```
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(kern_init)
```
这里规定了编译目标的体系结构为x86-32。并且将入口地址设置为`kern_init`。这个符号在`kern/init/entry.S`中。这也是整个内核的入口。

```
	PROVIDE(end = .);
```
这里进行了符号导出，将end符号导出为一个表明当前已经放入的内存段末尾地址的常量。在内核的物理内存管理中就使用这些符号作为空闲内存开始的标志。

```
+ ld bin/kernel
i386-elf-ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o
```
于是完成链接后得到`bin/kernel`的内核elf文件。


#编译bootloader
```
+ cc boot/bootasm.S
i386-elf-gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o
+ cc boot/bootmain.c
i386-elf-gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o
+ cc tools/sign.c
gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
+ ld bin/bootblock
i386-elf-ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
objcopy -S -O binary obj/bootblock.o obj/bootblock.out
bin/sign obj/bootblock.out bin/bootblock
'obj/bootblock.out' size: 472 bytes
build 512 bytes boot sector: 'bin/bootblock' success!
```
完成编译链接后用objcopy剥去调试信息得到二进制文件
这里的bin/sign的用途是讲bootloader的二进制文件写成一个合法的MBR。
```
    buf[510] = 0x55;
    buf[511] = 0xAA;
```
以上`tools/sign.c`中的代码就是合法MBR的要求: 使用0x55AA结尾。


#制作img文件
----------------
```
dd if=/dev/zero of=bin/ucore.img count=10000
dd if=bin/bootblock of=bin/ucore.img conv=notrunc
dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
```
dd的作用就是讲文件二进制拷贝到文件中。我们将之前的bootloader和kernel的二进制文件放倒ucore.img中就完成了ucore.img的制作。


