#使用gdb调试ucore
----------------
启动qemu进入调试模式的方式比较简单:
```
make gdb #makefile内写好了qemu的启动参数
```
gdb配置了.gdbinit文件
```
file bin/kernel
target remote :1234
break kern_init
```
这样的话gdb启动之后会首先停止在CS:IPk=0xfff0:0xfff0的BIOS启动位置，使用`info registers`指令可以看到x86-32 cpu上电后各个寄存器的初值。
使用gdb反汇编出的实际汇编指令如下:
```
=> 0x7c00:0x7c00    cli    
   0x7c01:0x7c01    cld    
   0x7c02:0x7c02    xor    %eax,%eax
   0x7c04:0x7c04    mov    %eax,%ds
   0x7c06:0x7c06    mov    %eax,%es
   0x7c08:0x7c08    mov    %eax,%ss
   0x7c0a:0x7c0a    in     $0x64,%al
   0x7c0c:0x7c0c    test   $0x2,%al
   0x7c0e:0x7c0e    jne    0x7c0a
   0x7c10:0x7c10    mov    $0xd1,%al
   0x7c12:0x7c12    out    %al,$0x64
   0x7c14:0x7c14    in     $0x64,%al
   0x7c16:0x7c16    test   $0x2,%al
   0x7c18:0x7c18    jne    0x7c14
   0x7c1a:0x7c1a    mov    $0xdf,%al
   0x7c1c:0x7c1c    out    %al,$0x60
   0x7c1e:0x7c1e    lgdtl  (%esi)
   0x7c21:0x7c21    insb   (%dx),%es:(%edi)
   0x7c22:0x7c22    jl     0x7c33
   0x7c24:0x7c24    and    %al,%al
   0x7c26:0x7c26    or     $0x1,%ax
   0x7c2a:0x7c2a    mov    %eax,%cr0
   0x7c2d:0x7c2d    ljmp   $0xb866,$0x87c32
   0x7c34:0x7c34    adc    %al,(%eax)
   0x7c36:0x7c36    mov    %eax,%ds
   0x7c38:0x7c38    mov    %eax,%es
   0x7c3a:0x7c3a    mov    %eax,%fs
   0x7c3c:0x7c3c    mov    %eax,%gs
   0x7c3e:0x7c3e    mov    %eax,%ss
   0x7c40:0x7c40    mov    $0x0,%ebp
   0x7c45:0x7c45    mov    $0x7c00,%esp
   0x7c4a:0x7c4a    call   0x7d00
   0x7c4f:0x7c4f    jmp    0x7c4f
```
反汇编出的命令与objdump出的汇编基本一致但是丢失了符号信息。
与原始的汇编相比主要的变化在加载gdt的部分的地址访问方式有一些变化。
