#1.4 内核的加载
---------------
当进入bootmain的时候内核的指令还放在硬盘中, bootmain需要将硬盘中的内核指令放倒内存中。
##硬盘的访问
硬盘的访问单位是一个个扇区。
硬盘控制器被映射到地址总线上。当需要读扇区的时候操作如下:
1. 向端口0x1F2写入需要读的扇区数。
2. 向0x1F3~0x1F6端口写入扇区号
3. 向0x1F7端口写入读指令0x20
4. 读0x1F7端口知道得到操作完成的信号
5. 连续读0x1F0端口就可以得到该扇区数据
具体的代码在`boot/bootmain.c`中的readsect和waitdisk函数中。

##elf格式代码的加载
在ELF的开头是一个ELF Header, 其中的格式如下:
```
struct elfhdr {
    uint32_t e_magic;     // must equal ELF_MAGIC
    uint8_t e_elf[12];    // readable string
    uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image
    uint16_t e_machine;   // 3=x86, 4=68K, etc.
    uint32_t e_version;   // file version, always 1
    uint32_t e_entry;     // entry point if executable
    uint32_t e_phoff;     // file position of program header or 0
    uint32_t e_shoff;     // file position of section header or 0
    uint32_t e_flags;     // architecture-specific flags, usually 0
    uint16_t e_ehsize;    // size of this elf header
    uint16_t e_phentsize; // size of an entry in program header
    uint16_t e_phnum;     // number of entries in program header or 0
    uint16_t e_shentsize; // size of an entry in section header
    uint16_t e_shnum;     // number of entries in section header or 0
    uint16_t e_shstrndx;  // section number that contains section name strings
};
```
ELF Header中给出了各个段的header的位置(e\_phoff和e\_phnum)，段header的表示格式如下:
```
/* program section header */
struct proghdr {
    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.
    uint32_t p_offset; // file offset of segment
    uint32_t p_va;     // virtual address to map segment
    uint32_t p_pa;     // physical address, not used
    uint32_t p_filesz; // size of segment in file
    uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）
    uint32_t p_flags;  // read/write/execute bits
    uint32_t p_align;  // required alignment, invariably hardware page size
};
```
其中的p\_va在链接过程中由load script确定, 实际是物理地址。然后就用p\_va和p\_memsz将这个段从硬盘装入内存。
最后跳转到elfhdr中指定的e\_entry。这样就开始了内核代码的执行。


