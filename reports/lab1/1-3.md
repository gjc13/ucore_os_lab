#1.3实模式与保护模式的切换
-----------------
在ucore中实模式和保护模式的切换在bootasm.S也就是BIOS之后的第一段代码发生，在切换到保护模式的过程中需要完成以下工作
* 打开A20地址线
* 进入保护模式
* 进入32位模式

##A20地址线
A20即为地址总线上的第21位。在8086时代，为了在16位CPU上支持20位的内存，Intel使用了段寄存器移位的方式，但是这样实际上可以产生21位的地址。所以在那时第21位地址被硬件屏蔽为0。
随着之后更大内存的出现，有了启用A20地址线的需要。但是为了保证兼容性，A20地址线默认是被可配置的外设屏蔽的。又由于不知何种原因，Intel决定使用8042键盘控制器的一个空闲引脚来干这件事，于是为了打开A20地址线，我们需要使用port io操作8042键盘控制器，大致的方式就是向8042的port2写入0xdf。

##GDT(Global Descriptor Table)表的载入
ucore中gdt表的设置非常简单: 段基址为0，大小为4G，不设置访问保护。
gdt表本身的定义在bootasm.S中:
```
# Bootstrap GDT
.p2align 2                                          # force 4 byte alignment
gdt:
    SEG_NULLASM                                     # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
gdtdesc:
    .word 0x17                                      # sizeof(gdt) - 1
    .long gdt                                       # address gdt
```
可以看到整个32位地址空间都被标记为可读可写可执行。
然后装载gdt表的指针gdtdesc:
```
    lgdt gdtdesc
```

##切入保护模式与32位模式
切入保护模式的方式为:将%cr0的CRO\_PE位标志为1, 实际代码如下:
```
    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0

    # Jump to next instruction, but in 32-bit code segment.
    # Switches processor into 32-bit mode.
    ljmp $PROT_MODE_CSEG, $protcseg

```
之后进入protcseg的指令就都运行在保护模式下。而ljmp会重新加载cs，这时CPU就可以发现我们设置的gdt表，于是切换到了32位模式下。
此时的cs寄存器就指向了gdt中code seg的描述符0x08。?
而之后又将data seg的描述符0x10手动加载到es ds ss fs gs中。就完成了内存GDT的初始化此时代码给出的线性地址直接就是物理地址。
之后跳转到bootmain开始加载内核。

