#1-X:用户态和内核态的切换
---------------
##用户态和内核态的切换
###trapframe的处理
基本的思路是修改trapframe，将内核态的trapframe修改到用户态，将用户态的trapframe修改到内核态。
需要注意的是由于内核态发生trap之后CPU并不会将esp和ss压栈，所以需要手动调整栈上的空间，具体的实现方式如下:
```
static void
lab1_switch_to_user(void) {
    //LAB1 CHALLENGE 1 : 2013011509
    //subl $8, %esp is a very tricky way "pad" the struct
    //In this way, although we trap from kernel to kernel,
    //tf->tf_esp and tf->tf_ss point to the memory we padded here.
    //So we can access and modify these fields without corrupting the kernel
    asm volatile (
        "subl $8, %%esp\n"
        "int %0\n"
        "movl %%ebp, %%esp"
        :
        :"i" (T_SWITCH_TOU)
    );
}

static void
lab1_switch_to_kernel(void) {
    //LAB1 CHALLENGE 1 : 201301509
    //movl %ebp, %esp forces to clear the stack
    asm volatile (
        "int %0\n"
        "movl %%ebp, %%esp"
        :
        :"i" (T_SWITCH_TOK)
    );

}
```
首先，在switch to user的过程中需要手动在栈上使用subl指令预先空余出esp和ss的空间。
在trap返回之后还要将esp直接拉回ebp的栈帧起始地址来清理栈上内存.
###具体的切换方法
对于用户态和内核态而言，最大的区别是cs段寄存器的最后两位的CPL不同，用户态为0x3，内核态为0x0。
所以同时需要设置所有数据段的DPL，以及访问外设时的IO指令使用的eflags的IOPL这些相应的权限。
具体而言切换中需要完成的工作如下
* 设置cs为KERNEL\_CS或者USER\_CS
* 设置ds ss es gs为KERNEL\_DS或者USER\_DS
* 设置EFLAGS将12,13位设置为ring 0或者ring 3
之后正常处理异常返回即可。在返回过程中我们设置的trapframe会被从内存放到寄存器中，这就完成了内核态和用户态的切换
##使用键盘进行切换
使用`cons_getc()`函数读入即可，但是要注意需要修改键盘中断处理函数，删去读取后打印的部分。


