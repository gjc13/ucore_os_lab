#1.6时钟中断设置
----------------
##启用Interrupt Descriptor Table
首先需要设置interrupt descriptor table:
```
void
idt_init(void) {
    extern uintptr_t __vectors[];
    int i;
    for(i = 0; i < 256; i++) {
        SETGATE(idt[i], 0, 0x08, __vectors[i], 0);
    }
    SETGATE(idt[T_SWITCH_TOU], 0, 0x08, __vectors[T_SWITCH_TOU], 3);
    SETGATE(idt[T_SWITCH_TOK], 0, 0x08, __vectors[T_SWITCH_TOK], 3);
    lidt(&idt_pd);
}
```
设置的含义如下：
* idt[i]为目标idt
* 0代表都使用trap模式
* 0x08实在bootasm中的第一个gdt，为code seg的gdt
* \_\_vectors[i]为入口向量地址
* 0表示ring 0，表明为内核态

之后将用于用户态切换到内核态的两个中断号设置为ring 3允许。
最后载入idt表地址即可。

##处理时钟中断
```
    case IRQ_OFFSET + IRQ_TIMER:
        ticks++;
        if(ticks % 100 == 0) {
            print_ticks();
        }
        break;
```
每次时钟中断增加ticks即可。

