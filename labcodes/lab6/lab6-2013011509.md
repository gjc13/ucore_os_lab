#Lab6 调度框架
##6-1调度框架与RR调度算法
---------------
###调度框架的基本调用方式
调度框架的各个函数的基本使用方式如下:
* init: 在sched\_init中调用, 用于进行初始化操作
* enque: 将进程放入就绪队列中
* deque: 将进程从等待队列中移除
* pick\_next: 返回调度器选出的下一个运行进程, 如果没有可选进程, 返回NULL
* proc\_tick: 每个时钟中断的回调

###调度框架的调度过程
首先每次时钟中断调用proc\_tick来减少当前进程的时间片
当当前进程的时间片用完或者yield或者等待时, `current->need_resched = 1`, 使用schedule函数重新调度.
在schedule函数中:
1. 调用enque如果当前进程处于运行状态, 将当前进程放入就绪队列中, RR算法直接将进程加入队尾
2. 用pick\_next获取下一个运行进程(在RR算法中就是队头), 如果成功获取, 调用deque从就绪队列中删除当前进程, 否则下一个调度进程为idle, RR算法将进程从链表中删除.
3. 按照实验5中的实现方式切换到下一个进程

###多级反馈队列的实现概述
最简单的方式是使用两个run queue, 一个放前台, 一个放后台, 然后两个run queye拥有一个调度框架的实现. 在这两个run queue中可以优先处理前台run queue, 只有当前台pick\_next为空的时候才调度后台的进程.

##6-2Stride调度算法
---------------------
使用了左式堆实现Stride调度算法, 整个左式堆的比较基准为`proc->stride`, 基本的主要函数实现如下:
* init: 清空左式堆
* enque: 将进程控制块直接放入左式堆中
* deque: 从左式堆中删除进程控制块
* pick\_next: 如果堆空, 就返回NULL, 否则返回堆顶, 同时进程的stride增加BIG\_STRIDE/priority, 然后为这个进程分配一个时间片
* proc\_tick: 降低时间片余留时间, 降低到0之后触发调度.

同时需要稍微修改进程控制块的初始化函数来初始化进程控制块中与stride调度有关的内容

BIG\_STRIDE的值在32位的INT\_MAX之内可以去一个较大的值, 我取了(1<<20)

由于不知道什么原因, lab6的参考答案根本没有实现stride调度算法, 所以我也不知道和答案有什么差异

##与OS原理课的关系
-------------------
1. 实现了RR, Stride调度算法, RR在原理中有详细解释
2. OS中对实时调度的一些知识点没有在本实验中实现.
