#Lab4 内核线程
##4-1 进程控制块的初始化
----------------
在进程控制块的初始化中, 我们进行基本的初始化操作, 主要重要的操作是将cr3页表基址寄存器设置到kernel的`boot_cr3`上. 然后设置进程状态为未初始化. 其他都是一些默认清空的操作.
这里基本的操作和答案中是一致的.

context保存了切换中使用的通用寄存器的值
tf保存了本进程上一次中断的trapframe, 也用于构造第一次执行时需要的整个上下文环境. 

##4-2 初始化新建的进程
----------------
新进程初始化的过程和实验教程中描述的相同:
* 调用alloc\_proc，首先获得一块用户信息块。
* 为进程分配一个内核栈: 使用`setup_kstack`
* 复制原进程的内存管理信息到新进程（但内核线程不必做此事）: 使用`clone_flags`控制`copy_mm`是否需要重新复制一份内存
* 复制原进程上下文到新进程: 使用`copy_thread`复制上下文信息
* 将新进程添加到进程列表: 需要用`hash_proc`添加到哈希表中以及用`list_add`加到总链表中.
* 唤醒新进程: 使用`wakeup_proc`
* 返回新进程号: 返回之前为进程分配的pid即可.

这里的各步和实验答案中给出的实现的区别是在分配pid插入链表的过程中没有屏蔽中断, 如果不屏蔽中断的话可能在另一个中断处理函数中同样分配了pid, 会引起数据冒险, 使得两个进程分配到相同的pid. 根据答案中的实现进行了修改.
`get_pid`函数是从上次分配的pid开始寻找可用的最小pid, 所以如果有之前的进程退出而分配又到了`MAX_PID`有可能会循环利用之前的pid, 所以并不是每个线程都有唯一的id, 但是同一时间fork出的线程的pid都是不一样的.
 
##4-3 进程的上下文切换
--------------
进程的上下文切换在`proc_run`函数中执行. 主要完成的工作为:
* 将内核栈切换到需要执行的进程的内核栈上
* 载入将要执行的进程的cr3一级页表地址
* 通过`switch_to`进行上下文切换, 其中完成了之前进程上下文的保存(保存通用寄存器到内存)和新进程上下文的恢复. 

一共创建了2个内核线程, 一个是init线程, 第二个是我们自己写的一个内核线程.

之所以要在switch前后屏蔽中断主要是为了防止这段切换代码在另一个中断处理中同时运行引起错误的current, 寄存器, 页表等共享资源的冲突.

#总结
---------------
涉及的操作系统的知识点:
* 进程控制块: 进程控制块是进程在内核中的唯一标识, 保存了所有进程控制信息
* 进程上下文切换: 进程通过切换页表和通用寄存器实现上下文切换
* fork: 实现了对于内核线程的fork

没有涉及的操作系统课程知识点:
轻量级进程
