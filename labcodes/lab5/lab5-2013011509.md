#Lab5 用户进程
##5-1应用程序的加载和执行
---------------
###设计概要
已经为我们完成了用户程序的elf文件加载到内存, 建立bss和用户态堆栈的过程, 我们主要需要设置第一次启动的trapframe. 
需要设置的如下:
* 将代码段和数据段的descriptor设置到用户态的两个对应descriptor上.
* 设置esp到用户态栈顶
* 将eip设置到elf的入口地址
* 设置eflags允许中断, 允许用户态可见的IO操作
实现和答案基本一致

###应用程序的加载过程
-------------
用户态进程调用exec系统调用加载一个应用程序.
然后调用到`do_execve`, 然后释放当前进程的资源, 调用`load_icode`加载新的应用程序
在`load_icode`中读取elf, 设置好用户程序的内存映射与内容, 然后设置了`current->tf`, 在这时中断返回的eip已经被修改为新elf的入口, 于是中断返回后程序就能正常开始执行了.

##5-2fork中内存的复制
---------------
###设计概要
获取父子进程对应页面的虚拟地址后之久使用memcpy复制. 之后用`page_insert`函数将这一页插入子进程的页表中即可. 与参考答案中也没有太大不同

###Copy on write
* 在`dup_mmap`中, 将子进程的页表项直接设置为父进程的页表项, 但是将父子进程页表项的权限位都取消写权限.
* 之后发生非法写异常时, 按照如下方式判断: 
1. `vma_struct`不允许写, 非法访问异常
2. `vma_struct`允许写, 检查对应Page结构体的引用计数, 如果引用计数大于1, 需要重新分配一页, 修改当前进程这一页的页表项到新的页上, 新的页是可写的. 如果引用计数为1, 说明已经没有其他进程在共享这一页, 直接将页表修改为可写即可.

这里都没有讨论页被换出的情况, 在发生非法写异常时如果页被换出, 要重新换入这一页然后用上述方式操作.

##5-3系统调用对进程状态的影响:
新创建的进程处于UNINIT状态
fork后的父子进程都是RUNNABLE
wati如果有正在运行的子进程, 父进程变为SLEEPING, 否则直接返回, 父进程继续运行.
exit释放进程资源, 将本进程设置为ZOMBIE状态. 如果父进程在等待子进程结束就唤醒父进程, 将自己的子进程挂到init下, 如果init在等待子进程结束唤醒init.

基本的状态转换如下:
UNINIT                       ZOMBIE
   |                           ^
   | fork                      | exit
   v             schedule      |
RUNNABLE-------------------> RUNNING
      ^                        |
      |                        | do_wait
      |       wakeup_proc      v
       ---------------------- SLEEPING

#总结
---------------
##涉及的OS知识点
1. 复习了x86中的权限管理方式
2. 实现了fork exec系统调用
3. 了解了进程的三状态模型
##没有涉及的OS知识点
五状态模型
