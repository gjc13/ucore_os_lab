#Lab7 进程同步互斥
##7-1 信号量
-----------------
###内核级信号量的实现 
本实验中ucore通过关中断的方式实现了对`sem->value`的测试和增减操作的原子性.这种方式只能适用于单CPU的情况.
如果发现在down操作的过程中资源已经耗尽, 那么将当前进程加入等待队列中, 然后直接schedule. 
在up操作中, 如果发现之前的等待可以满足, 那么从等待队列中唤醒一个进程, 将它标记为就绪状态放到调度器的就绪队列中, 之后调度器会开始执行这个进程.
###用内核级信号量执行哲学家就餐问题
首先将放叉子和拿叉子这些操作作为临界区使用互斥mutex同步.
每个哲学家再使用一个信号量进行等待放叉子这样的操作, 如果哲学家发现自己可以得到两只叉子, 对信号量执行V操作增加一个资源, 然后在取叉子的时候使用P操作获取资源即可.
###用户态信号量的实现
将初始化, up和down操作封装为系统调用, 内部仍然使用我们现在对于信号量的实现. 
向用户返回的可以是一个代表信号量的descriptor, 然后用户将descriptor通过参数传入系统调用, 就可以知道需要访问那个信号量, 然后做对应操作即可.

##7-2 管程
--------------------
###内核管程
所有竞争管程的线程共用一个锁mutex来保证临界区不会有竞争访问, 同时使用另一个信号量next在竞争管程间的线程轮转.
一个典型的执行流程如下:
1. 第一次调用wait后放弃锁, 等待其他线程signal.
2. 调用signal的线程获取锁, 然后将自己放入等待的next中, 通过next信号量试图唤醒等待signal的线程, 自己一方面仍然持有锁, 一方面进入等待状态这样也防止了其他线程进入临界区.
3. 之前wait的线程继续执行结束, 发现有等待的signal线程, up next信号量是的signal线程继续执行
4. signal线程执行完毕, 释放mutex使得其余线程可以进入管程

###使用内核管程执行哲学家就餐问题
哲学家检查自己左右都不在就餐时才可以就餐.
如果发现自己试图就餐不成功就持续等待条件变量.
每次哲学家就餐完成后检测左右是否可以就餐, 如果可以就向条件变量signal.

###用户态管程的实现
相似地可以将一个monitor封装成一个descriptor, 然后将init signal和wait封装成系统调用, 通过向系统调用传入descriptor和参数来使用管程的功能.

###与参考答案的异同
基本的实现方式和参考答案一致, 但是由于实际实现的是一个Hoare管程, 所以直接使用了if做条件判断.

##OS中知识点
----------
涉及了信号量和管程的实现
没有涉及读写锁的实现和使用.
